# Multi-Agent Contract-Layer Guide ("Universe" Edition)

This document formalises how **three concurrent code-generation agents**—or three human teams—can collaborate on one codebase without stepping on each other.  It builds on the concepts in `LLM_DEVELOPMENT_GUIDE.md` and spells out the *minimal contracts*, versioning rules, and CI gates that hold the system together.

> Terminology  
> **LLM-S** Schema / Domain owner  
> **LLM-I** Service Implementer  
> **LLM-U** UI / Interaction designer

---

## 1 Folder Ownership Matrix

| Folder / File                          | Owner  | Purpose                                                   |
|----------------------------------------|--------|-----------------------------------------------------------|
| `shared/schema.ts` & `migrations/`     | **S**  | Canonical DB schema (Drizzle types, Zod validators)       |
| `client/src/contract/`                 | **S**  | Pure TS interfaces + version constants (the API spec)     |
| `client/src/impl/`                     | **I**  | Concrete implementations of contract (`supabase`, `http`) |
| `client/src/components/`, `pages/`     | **U**  | React (or other) presentation layer                      |
| `tests/schema/`                        | **S**  | Migration smoke tests                                     |
| `tests/impl/`                          | **I**  | Unit / integration tests for service code                |
| `tests/ui/`                            | **U**  | Storybook / Cypress / Jest snapshot tests                |

Nobody else edits another agent's folder; PRs will be rejected by CI.

---

## 2 Version Constants

```ts
// client/src/contract/version.ts
export const SCHEMA_VERSION   = "2025-07-02.00";   // Bumped only by LLM-S
export const CONTRACT_VERSION = "2025-07-02.01";   // Bumped only by LLM-S
```

```ts
// client/src/impl/supabaseLogService.ts (example)
export const IMPLEMENTATION_VERSION = "2025-07-02.01"; // Bumped by LLM-I
```

**Rules**
1. `SCHEMA_VERSION` ≥ previous value when schema changes.  
2. `CONTRACT_VERSION` ≥ previous value when any *interface* in `contract/` changes.  
3. `IMPLEMENTATION_VERSION` must **equal** `CONTRACT_VERSION` in the PR that implements new methods.  
4. UI code does **not** carry a version; it just compiles against `contract/`.

---

## 3 Minimal Shared Contracts

1. **Database Truth** – `shared/schema.ts`  
   *Generated by Drizzle; referenced only by LLM-S & LLM-I.*

2. **TypeScript API Spec** – `client/src/contract/*.ts`  
   Contains `RunMeta`, `LogRow`, and the `LogService` interface.

3. **Implementation Version Flag** – Each service file exports `IMPLEMENTATION_VERSION`.

These three items are the *only* artefacts that all agents must respect.

---

## 4 Compiler & CI Guardrails

| Step | Tool / Script | Fails when… |
|------|---------------|-------------|
| **Type Safety** | `tsc --noEmit` | UI or impl imports missing contract symbols |
| **Version Sync** | `scripts/checkVersions.ts` | `IMPLEMENTATION_VERSION < CONTRACT_VERSION` |
| **Schema Tests** | Jest + `drizzle-kit` | Migrations fail to apply in fresh DB |
| **Impl Smoke** | Jest | Each `LogService` impl throws or returns wrong shape |
| **UI Tests** | Storybook/Cypress | Visual or interaction regressions |

A PR must pass *all* gates.

---

## 5 Prompt Blueprints

### 5.1 LLM-S (Schema Owner)
```
You own /shared/schema.ts and /client/src/contract/*.
1. Apply requested domain change. 2. Regenerate types. 3. Bump SCHEMA_VERSION and CONTRACT_VERSION.
Do NOT edit /impl/ or /components/.
```

### 5.2 LLM-I (Service Implementer)
```
Implement concrete code so that all functions required by /client/src/contract/* compile.
Update IMPLEMENTATION_VERSION to match CONTRACT_VERSION.
Add/adjust unit tests under /tests/impl/.
Do NOT touch /components/ or /shared/schema.ts.
```

### 5.3 LLM-U (UI Designer)
```
Render UI using only `import { logService } from '@/contract'`.
If a needed method is missing, stub it in the interface and add a TODO comment—CI will fail and alert LLM-I.
Do NOT reference Supabase, fetch, or SQL.
```

---

## 6 Workflow Example

1. **Product asks**: "Add a DEBUG level."
2. **LLM-S** updates enum, bumps versions, PR passes schema tests but fails version sync (impl behind) → merged.
3. **LLM-I** implements new level handling in Supabase & mock services, bumps `IMPLEMENTATION_VERSION`, PR passes.
4. **LLM-U** adds UI filter pill; compiler already knows about new enum value.

Total wall-clock time can be minutes, agents work in parallel, CI orchestrates reconciliation.

---

## 7 Why This Works for LLMs

* **Stateless contracts** are easy for language models to keep in working memory.  
* The compiler is the objective arbiter—no brittle natural-language instructions required.  
* Version constants give CI a trivial numeric check for drift.  
* Folder ownership prevents prompt bleed ("mucking with the UI while changing DB code").

Use this guide as the canonical reference whenever you spin up multi-agent workstreams in this repository or its descendants. 