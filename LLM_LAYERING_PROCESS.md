# Layer-First Development Workflow for LLM Teams

This guide is meant to be **handed directly to language-model agents** (or human teams) *before any code exists*.  It tells them how to go from a narrative product spec to a fully layered codebase like the one in this repo—while ensuring each layer can be developed, mocked, and tested in isolation.

The workflow assumes **three roles** (Schema, Service, UI) but generalises to more.

---

## 0 Glossary

| Term | Who Produces | Purpose |
|------|--------------|---------|
| **Spec Story** | Product / PM | Narrative requirements, user goals, acceptance criteria. |
| **ERD Draft** | Schema LLM | Entities, relationships, field names. |
| **Contract Draft** | Service LLM | Pure TypeScript interfaces expressing all needed operations. |
| **Minimal UI** | UI LLM | A bare HTML/React page that calls every contract function once. |

Each artefact is version-controlled and can iterate independently.

---

## 1 Decision Table – "Where does this logic live?"

| Question | Yes → | No → |
|----------|-------|-------|
| Will two different screens/services need this calculation? | **Service Layer** | UI Layer |
| Could wrong output corrupt or leak data? | **Service Layer** | UI Layer |
| Is it pure formatting / presentation? | UI Layer | Service Layer |
| Does it require DB access or secrets? | Service / Schema | UI Layer |
| Does it define storage structure? | **Schema Layer** | Service Layer |

Rule of thumb: **If a mistake harms only the pixels on one screen, leave it in the UI. Otherwise, push it down.**

---

## 2 End-to-End Generation Process

1. **Spec Upload**  (human → all LLMs)  
   Plain-language story, user flows, edge cases.

2. **Phase A Schema Proposal**  
   *LLM-S* reads the story, outputs:
   * `ERD.md` — entities & relationships.  
   * `shared/schema.ts` — Drizzle definitions + Zod inserts.  
   * Bumps `SCHEMA_VERSION` to `YYYY-MM-DD.00`.

   ✅ *Human / QA review* — approve or comment.

3. **Phase B Contract Proposal**  
   *LLM-I* reads **ERD** + story, outputs:
   * `client/src/contract/*.ts` — methods covering every required user action.  
   * `CONTRACT_VERSION = SCHEMA_VERSION + .01`.

   ✅ Gate: must compile **without** implementation (`any` return OK for now).

4. **Phase C Minimal UI Scaffold**  
   *LLM-U* reads **contract** + story, outputs:
   * `client/src/pages/min-ui.tsx` — shows a button per contract method, prints JSON results.  
   * No styling; plain HTML allowed.  
   * Uses an **in-memory mock** automatically generated by LLM-I.

5. **Phase D Service Implementation**  
   *LLM-I* produces `impl/supabaseService.ts` (or mocks) fulfilling the contract.  
   * Sets `IMPLEMENTATION_VERSION = CONTRACT_VERSION`.  
   * Provides Jest tests per method.

6. **Phase E UI Feature Work**  
   Once minimal UI passes tests, *LLM-U* starts building real components, one PR per feature.

Every phase can begin while the previous one is under review; version constants plus CI protect coherence.

---

## 3 Mock & Test Strategy

| Layer | Mock Role | Test Focus |
|-------|-----------|------------|
| Schema | SQLite / in-mem Postgres | Migrations apply, constraints hold. |
| Service | `inMemoryLogService.ts` | All contract functions resolve, return correct shapes. |
| UI | Storybook + Jest DOM | Components render with mock service, no runtime errors. |

CI matrix runs **schema → service → UI** so breakage surfaces early.

---

## 4 Prompt Snippets per Phase

### Phase A Schema
```
SYSTEM: You are LLM-S. Produce Drizzle schema & Zod types from the story. Do NOT create UI or contract code.
USER: {story_markdown_here}
```

### Phase B Contract
```
SYSTEM: You are LLM-I acting in Contract mode. Using /shared/schema.ts, define TypeScript interfaces that a UI would need. No runtime code. Update CONTRACT_VERSION.
```

### Phase C Minimal UI
```
SYSTEM: You are LLM-U. Generate a single React page that imports {contract} and calls every method. Minimal HTML.
```

### Phase D Implementation
```
SYSTEM: You are LLM-I acting in Implementation mode. Implement each contract function using Supabase JS, update tests, bump IMPLEMENTATION_VERSION.
```

---

## 5 Scaling Beyond Three Agents

Add roles but keep *one* contract source of truth:
* **LLM-A** Accessibility / a11y audits – edits only UI tests.  
* **LLM-P** Performance tuning – edits service caching layers.

CI remains the referee.

---

## 6 When to Break the Rules

1. Prototype spikes — Allow UI to call Supabase directly, but gate keep via `// @ts-expect-error PROTOTYPE` comments and delete before merge.
2. Emergency hotfix — A human can edit across layers; must open a follow-up PR to re-establish boundaries.

---

*Follow this process and large, multi-layer features can be generated, mocked, and verified in parallel, whether the authors are silicon or carbon.* 